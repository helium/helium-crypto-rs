use num_bigint_dig::BigUint;
use rsa::RsaPublicKey;
use std::array::TryFromSliceError;
use std::convert::TryFrom;
use std::convert::TryInto;

use thiserror::Error;

#[derive(Debug, Error)]
pub enum Error {
    #[error("Key blob length is to small: {0}")]
    KeyBlobLength(usize),

    #[error("Magic number read failed")]
    MagicNumber,

    #[error("Version read failed")]
    Version,

    #[error("Digest padding read failed")]
    DigestPadding,

    #[error("Bad digest padding value: {0}")]
    DigestPaddingValue(u32),

    #[error("Modulus read failed")]
    Modulus,

    #[error("Public exponent read failed")]
    PublicExponent,

    #[error("Private exponent read failed")]
    PrivateExponent,

    #[error("Failed to create RsaPublicKey")]
    RsaPublicKey,
}

pub enum DigestPadAlgo {
    RsaDigestPaddingNone = 0,
    RsaPkcs115Sha2_256 = 1,
    RsaPssSha2_256 = 2,
}

impl TryFrom<u32> for DigestPadAlgo {
    type Error = Error;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(DigestPadAlgo::RsaDigestPaddingNone),
            1 => Ok(DigestPadAlgo::RsaPkcs115Sha2_256),
            2 => Ok(DigestPadAlgo::RsaPssSha2_256),
            _ => Err(Error::DigestPaddingValue(value)),
        }
    }
}

// Note (iegor.s): values are copied from qualcomm qseecom module
const RSA_KEY_SIZE_MAX: usize = 512 + 16;
const RSA_IV_LENGTH: usize = 16;
const RSA_HMAC_LENGTH: usize = 32;
const RSA_KEY_BLOB_LENGHT: usize = 1656;

fn read_u32_le(buf: &[u8]) -> Result<(u32, &[u8]), TryFromSliceError> {
    let (val_bytes, rest) = buf.split_at(4);
    let parsed = u32::from_le_bytes(val_bytes.try_into()?);
    Ok((parsed, rest))
}

fn read_u8_array_dynamic(
    buf: &[u8],
    maxsize: usize,
) -> Result<(Vec<u8>, &[u8]), TryFromSliceError> {
    let (arr_bytes, rest) = buf.split_at(maxsize);
    let (arr_len, rest) = read_u32_le(rest)?;
    let arr = arr_bytes[..arr_len as usize].to_vec();
    Ok((arr, rest))
}

fn read_u8_array(buf: &[u8], size: usize) -> (Vec<u8>, &[u8]) {
    let (arr_bytes, rest) = buf.split_at(size);
    let arr = arr_bytes.to_vec();
    (arr, rest)
}

pub fn parse_key_blob(buf: &[u8]) -> Result<RsaPublicKey, Error> {
    // Key blobs are always exactly RSA_KEY_BLOB_LENGHT long, but
    // let's tolerate extra.
    if buf.len() < RSA_KEY_BLOB_LENGHT {
        return Err(Error::KeyBlobLength(buf.len()));
    }

    let (_, rest) = read_u32_le(buf).map_err(|_| Error::MagicNumber)?;
    let (_, rest) = read_u32_le(rest).map_err(|_| Error::Version)?;
    let (digest_padding, rest) = read_u32_le(rest).map_err(|_| Error::DigestPadding)?;
    let _ = DigestPadAlgo::try_from(digest_padding)?;
    let (modulus, rest) =
        read_u8_array_dynamic(rest, RSA_KEY_SIZE_MAX).map_err(|_| Error::Modulus)?;
    let (public_exponent, rest) =
        read_u8_array_dynamic(rest, RSA_KEY_SIZE_MAX).map_err(|_| Error::PublicExponent)?;
    let (_, rest) = read_u8_array(rest, RSA_IV_LENGTH);
    let (_, rest) =
        read_u8_array_dynamic(rest, RSA_KEY_SIZE_MAX).map_err(|_| Error::PrivateExponent)?;
    let (_, _) = read_u8_array(rest, RSA_HMAC_LENGTH);

    RsaPublicKey::new(
        BigUint::from_bytes_be(modulus.as_slice()),
        BigUint::from_bytes_be(public_exponent.as_slice()),
    )
    .map_err(|_| Error::RsaPublicKey)
}

#[cfg(test)]
mod tests {
    use hex_literal::hex;

    #[test]
    fn verify_parse() {
        const BLOB: &[u8] =
            &hex!("AABBCCDD0000000001000000AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000AABBCCDD000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899");
        assert!(super::parse_key_blob(BLOB).is_ok());
    }
}
